#!/usr/bin/env python

import argparse
import os
import subprocess
import sys
import tempfile


def yield_paths(args):
    for root, dirs, files in os.walk(args.path):
        paths = []
        if not args.no_files:
            paths.extend([os.path.join(root, path) for path in files])
        if not args.no_directories:
            paths.extend([os.path.join(root, path) for path in dirs])

        for path in sorted(paths):
            yield os.path.abspath(path)

        if not args.recursive:
            del dirs[:]


def path_for_user(root_path, path):
    assert os.path.isabs(root_path)
    assert os.path.isabs(path)

    return os.path.relpath(path, root_path)


def path_from_user(root_path, path):
    assert os.path.isabs(root_path)

    return os.path.join(root_path, path)


def interact(args, old_paths):
    assert os.path.isabs(args.path)

    fwrite = tempfile.NamedTemporaryFile(mode='w', delete=False)
    tmp_path = fwrite.name
    relative_old_paths = [path_for_user(args.path, path) for path in old_paths]
    fwrite.write("\n".join(relative_old_paths))
    fwrite.close()

    subprocess.call([args.editor, tmp_path])

    fread = open(tmp_path, 'r')
    relative_new_paths = fread.read().splitlines()
    new_paths = [path_from_user(args.path, path) for path in relative_new_paths]
    fread.close()

    os.remove(tmp_path)
    return new_paths


def rename(args, old_names, new_names):
    assert len(old_names) == len(new_names)
    for old, new in zip(old_names, new_names):
        assert os.path.isabs(old)
        assert os.path.isabs(new)
        # Don't rename if the name is unchanged
        if old == new:
            continue

        sys.stdout.write(
            str.format("Moving \"{}\" to \"{}\".\n",
                        path_for_user(args.path, old),
                        path_for_user(args.path, new)))
        if not os.path.exists(new):
            if args.parents:
                os.renames(old, new)
            else:
                os.rename(old, new)
        else:
            sys.stderr.write(
                str.format("Warning: file {} already exists.\n",
                            path_for_user(args.path, new)))


def program(args):
    old_names = list(yield_paths(args))
    new_names = interact(args, old_names)

    if len(new_names) == 0:
        sys.stderr.write("Aborting rename due to empty input.\n")
        return 1

    if len(new_names) != len(old_names):
        sys.stderr.write("Error: number of lines have changed, exiting.\n")
        return 1

    rename(args, old_names, new_names)


def main():
    parser = argparse.ArgumentParser(
        description="Interactively rename files.",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    parser.add_argument(
        "path",
        type=os.path.abspath,
        nargs='?',
        default='.',
        help="directory to rename files in")

    parser.add_argument(
        "-p", "--parents",
        action="store_true",
        help="make parent directories as needed")
    parser.add_argument(
        "-r", "--recursive",
        action="store_true",
        help="recurseivly rename in sub-directories")
    parser.add_argument(
        "-f", "--no-files",
        action="store_true",
        help="only rename files")
    parser.add_argument(
        "-d", "--no-directories",
        action="store_true",
        help="only rename directories")
    parser.add_argument(
        "-e", "--editor",
        action="store",
        help="the editor to use",
        default=os.environ["EDITOR"])

    sys.exit(program(parser.parse_args()))

main()
